# 2주차

### [멘토링 질문 목록]

Q. 왜 단순히 “문법 암기”보다 “동작 원리 이해”가 중요할까? <br />
A. 문법은 그저 코딩을 하기 위한 언어를 쓰기 위한 방법일 뿐이지 우리에게 주어진 문제를 코딩으로 해결을 하려면 동작 원리를 이해해야지 상황에 맞는 최적화된 코드를 작성할 수 있으니까.

Q. 실제 코드 디버깅할 때 “원리 이해”가 필요한 순간을 예로 들어볼 수 있을까? <br />
A. 재귀 함수 디버깅 할때라든가 콜백 함수가 언제 동작하는지 파악할때...? 사실 정확히 어떤 구체적인 상황이 있을지 잘 모르겠다. 그냥 필요할때, 매 순간이 될 수도 있는거 아닌가?

Q. 프론트엔드 개발에서 “동작 원리”를 이해하고 있는 사람과 그렇지 않은 사람의 차이는? <br />
A. 동작원리를 이해한 사람은 주어진 문제를 현재의 상황에 적용하려고 할 때 가장 최선의 선택을 할 줄 안다. 동작 원리를 이해하지 못한 사람은 그저 돌아가기만 하는 코드를 작성할뿐이다.

Q. JS는 어떤 언어 패러다임(특징)? (예: 프로토타입 기반, 동적 타이핑 등) <br />
A. 프로토타입 기반 객체 지향 언어이며 동적 타이핑이며, 유일하게 브라우저에서 실행되는 언어이다.

Q. 브라우저 외에서 JS가 실행되는 환경은? <br />
A. Node.js 환경

Q. 자바스크립트가 “싱글 스레드”라는 말은 정확히 무슨 뜻? <br />
A. 콜스택이 1개이다. 한 번에 하나의 작업만 처리할 수 있다.

Q. 브라우저 콘솔에서 실행되는 JS와 Node.js에서 실행되는 JS의 차이는? <br />
A. 브라우저에서 실행되는 JS는 브라우저 자바스크립트 엔진이 실행하는 것이고, Node,js에서 실행되는 JS는 런타임 환경에서 실행되는 것이다. <br />
**(틀렸음 X => 둘 다 JS 엔진이 실행하는 것이고, 각각의 런타임 환경이 제공하는 API와 전역 객체가 다르다)**

Q. transpiler / bundler는 어떤 역할? <br />
A. 트랜스파일러는 구버전 브라우저에 호환될 수 있는 문법으로 바꿔주는거...? 번들러는 뭘 말하는건지 모르겠다. <br />
**(알아봄 => 이걸 왜 까먹었지... 번들러가 웹팩 말하는거였구나...)**

Q. Babel과 Vite, Webpack은 각각 어떤 레이어? <br />
A. 바벨은 자바스크립트, CSS 등 최신 문법을 구버전 브라우저에 호환될 수 있게 변환해주는 트랜스파일러이고, 웹팩은 여러개의 모듈 파일을 하나로 합쳐주는 도구, vite는 실행 속도를 빠르게 올려주는...음... 웹팩이랑 비슷한건데 걍 더 빠른거...????? 아 큰 차이가 웹팩은 하나로 합쳐지는 과정이 느린데, vite는 한줄한줄을 실행해서 빠르다고 했던가? <br />
**(알아봄 => 웹팩은 모든 코드를 사전에 번들링하지만, vite는 브라우저의 es module 기능을 활용해 필요한 모듈만 실시간 변환 및 제공하는 차이점을 가지고 있음, 즉 vite는 브라우저가 import할 때마다 해당 파일만 트랜스파일링해서 빠름)**

Q. 브라우저 동작 원리? <br />
A. HTML, CSS, JS 파일 요청 -> 구문 분석 -> DOM 트리 구축 -> script 구문을 만나면 HTML 파싱 중단 -> JS 실행 후 종료 -> CSSOM 구축 -> 렌더 트리 합성 -> 페인팅

Q. 브라우저가 HTML, CSS, JS를 어떻게 처리해서 화면을 그릴까? <br />
A. HTML은 구문 분석을 통해 DOM 트리를 구축하고, CSS도 구문 분석을 통해 CSSOM을 구축한다. JS같은 경우 HTML 구문 분석중 script 구문을 만나면 DOM 트리 구축이 일시정지 되었다가 브라우저 자바스크립트 엔진이 JS 코드를 실행한 후 종료 되면 다시 HTML 파서로 제어 권한을 넘긴다

Q. Reflow와 Repaint의 차이는? <br />
A. 리플로우는 브라우저에서 최초로 그려질때 레이아웃을 잡고 그리는 과정, 리페인팅은 브라우저에서 레이아웃이 바뀌는 현상이 일어나면 다시 렌더링 하는 과정. <br />
**(틀렸음 => 리플로우는 DOM의 레이아웃을 다시 계산하는 과정, 리페인트는 요소의 시각적 스타일을 다시 그리는 과정. 리플로우가 일어나면 반드시 리페인트가 뒤따르지만, 리페인트는 리플로우 없이도 발생 가능)**

Q. JS가 렌더링에 영향을 주는 이유는? <br />
A. 무슨 대답을 해야하는 질문인지 모르겠어요... 브라우저의 렌더링 과정에 필수적으로 포함된 과정인데 무슨 영향을 말하는걸까요? 왜 JS를 만나면 중간에 HTML 파싱을 멈추는지에 대한 질문일까요?

Q. JS의 기본 타입(primitive)과 참조 타입(reference)의 차이? <br />
A. 기본 타입은 number, string, boolean과 같은 변경 불가능한 값을 의미하고, 참조 타입은 객체이며, 프로퍼티와 메서드를 포함할 수 있는 변경 가능한 값이다.

Q. null과 undefined의 차이? <br />
A. null은 개발자가 의도적으로 값이 없음을 표시한 값이고, undefined는 자바스크립트 엔진이 의도적으로 값이 없음을 초기화한 값이다.

Q. 변수는 메모리 상에서 어떤 역할? <br />
A. 변수는 메모리에 저장된 값의 위치를 개발자가 쉽게 이해할 수 있는 식별자의 역할을 해준다.

Q. Pass by Value vs Pass by Reference <br />
A. 함수 호출 시 인자가 어떻게 전달되는지에 대한 개념이었다. 개념만 알아채고 내가 이해한바로 답변하면, pass by value는 함수에 전달할때 값이 복사되어 전달이 된다. 그래서 값이 변경되지 않고, 재할당을 하면 기존 값을 버리고 새로운 값으로 메모리에 할당하고 전달한 변수 값의 메모리 주소를 변경한다. pass by refetence는 객체의 참조값(메모리상 위치)가 복사되어 전달되는 것이며, 함수 내부에서 객체의 값을 추가하거나 변경하면 원본 객체도 같이 변경된다. pass by value처럼 메모리에 값이 다시 할당되는것이 아니며, 메모리에 위치한 기존 객체의 값이 변경되는 것이다. 그 이유는 메모리상 위치값만 복사되는 것이지 객체 자체가 복사되는게 아니여서 그렇다.

Q. Truthy Falsy? <br />
A. 자바스크립트는 0, 1과 같은 값을 참에 가까운 값, 거짓에 가까운 값으로 판단하여 결정한다
**(좀 더 명확함 필요 => 자바스크립트는 형변환을 할때 모든 값을 명시적으로 truthy 혹은 falsy로 형변환해서 판단한다)**

Q. 단축 평가(Short-circuit evaluation)? <br />
A. 처음 들어보는 말이에요 <br />
**(알아봄 => 논리 연산에서 왼쪽 피연산자의 값만으로 결과가 이미 결정되면 오른쪽 피연산자는 평가하지 않고 그대로 반환하는 것을 의미)**

Q. 타입 자동 변환? 타입 추론? <br />
A. 자바스크립트는 동적 타이핑 언어라서 타입을 그때그때 평가해서 바꾼다. <br />
(이걸 물어보는게 맞나요..? 아님 타입 자동 변환, 타입 추론의 정의를 물어보시는?) <br />
타입 자동 변환이란 자바스크립트가 해당 값의 타입을 그때그때 평가한다. 타입 추론이란 typeof로 추론이 가능하다..? <br />
**(타입 추론 틀림 => 타입 추론은 정적 타입 언어(타입스크립트)에서 개발자가 타입을 명시하지 않아도 컴파일러가 타입을 자동으로 추측하는 기능이다.)**

Q. 암묵적 변환(Implicit coercion) <br />
A. 자바스크립트는 예를 들어 `문자열 + 숫자` 같은 계산식을 만나면 숫자를 문자열로 암묵적 변환을 시킨다. 이와 같이 문맥에 따라 변환을 시키는걸 의미한다.

Q. 명시적 변환(Explicit conversion) <br />
A. 개발자가 의도적으로 형변환 하는 것을 의미한다.

Q. null 병합 연산자(??) vs OR(||) <br />
A. null 병합 연산자는 왼쪽 피연산자가 null 또는 undefined이면 오른쪽 피연산자 값으로 반환 또는 할당됨. OR 연산자는 왼쪽 피연산자가 참이면 오른쪽 피연산자는 계산하지 않고 왼쪽 피연산자의 값을 반환함.

Q. 얕은 복사 vs 깊은 복사? <br />
A. 객체를 얕은 복사로 하게 된다면 중첩된 프로퍼티, 메서드의 값이 변경되질 않지만, 깊은 복사를 하면 변경할 수 있다. <br />
**(틀렸음 => 객체 내부의 중첩된 참조값까지 복사하느냐 (깊은 복사), 겉부분 1단계만 복사하느냐(얕은 복사) 차이. 얕은 복사는 중첩 객체를 같은 참조로 복사하기 때문에 변경이 원본에도 영향을 주고, 깊은 복사는 서로 독립적으로 변경 되느냐의 차이. 얕은 복사의 중첩된 객체는 같은 메모리 주소를 참조, 깊은 복사는 중첩된 객체까지 모두 새로운 메모리 공간에 복사하여 독립적으로 존재)**

Q. 왜 변경 불가성이 중요할까? (React에서의 예시도 좋음) <br />
A. 어떤거의 변경 불가성을 의미하시는건가요? 얕은 복사, 깊은 복사와 이어지는 질문인가요...? 원본이 수정되면 여기저기서 막 수정될 위험이 있으니까?

Q. const는 진짜 불변일까? <br />
A. 아니요 객체로 생성된 const 변수는 재할당이 불가능하지 객체의 프로퍼티, 메서드는 변경이 가능해집니다.

Q. 객체를 복사했는데 원본이 바뀌는 이유는? <br />
A. 얕은 복사, 깊은 복사의 차이와 답변 동일

Q. map, filter, reduce, 깊은 복사 각각 직접 구현하기

#### map

도저히 한줄도 못 쓰겠어서.. GPT한테 '개발자가 자바스크립트 전역에 `[1, 2, 3].mapWarp((i) => console.log(i));` 이런 형식의 `mapWrap` 함수를 만들어서 사용할 수 있나요?' 라고 물어보고 힌트를 얻어서 작성했습니다 <br />
맨 처음엔 `map([1, 2, 3, 4])` 이렇게 일반 함수로 만드려다가 기존 `map`이랑 똑같은 형태로 만들고 싶어서 욕심 부렸는데 떠오르는게 없었습니다 <br />
GPT가 건넨 답변 보고 poiemaweb에서도 보고 TIL도 썼으면서 왜 이렇게 만들자란 생각을 못했나 아차 싶었습니다ㅠㅠ

```javascript
Array.prototype.customMap = function (callback) {
  if (typeof this !== "object" || typeof callback !== "function") return;
  const result = [];

  this.forEach((value, index, array) => {
    result[index] = callback(value, index, array);
  });

  return result;
};
```

#### filter

```javascript
Array.prototype.customFilter = function (callback) {
  if (typeof this !== "object" || typeof callback !== "function") return;
  const result = [];

  this.forEach((value, index, array) => {
    if (!!callback(this[index], index, array)) {
      result.push(value);
    }
  });

  return result;
};
```

#### reduce

```javascript
Array.prototype.customReduce = function (callback, initialValue) {
  if (typeof this !== "object" || typeof callback !== "function") return;

  let result = initialValue;

  for (let i = 0; i < this.length; i++) {
    result = callback(result, this[i], i, this);
  }

  return result;
};
```

#### 깊은 복사

```javascript
function deepCopy(obj) {
  const result = {};

  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value !== null || typeof value !== undefined) {
      result[key] = value;
      deepCopy(value);
    }
  });

  return result;
}
```
