# 4주차

Q. 프로토타입 기반 상속이란 무엇인가? <br />
A. 부모 객체의 프로퍼티와 메서드를 상속받아 사용할 수 있는데 이러한 부모 객체를 프로토타입이라고 하고 상속 받는걸 프로토타입 기반 상속이라고 한다

> 프로토타입 기반 상속은 객체가 다른 객체(프로토타입)을 내부적으로 링크하여, 자신에게 없는 프로퍼티나 메서드를 그 프로토타입에서 찾아 사용하는 방식이다. 이 링크 구조를 프로토타입 체인이라고 한다.

Q. 프로토타입 체인은 무엇이고 어디까지 이어질까? <br />
A. 상속받은 부모의 프로토타입이 연결된 형태를 의미하며 어디까지 이어질지는 모르겠다

> 프로토타입 체인은 객체의 내부 슬록 [[Prototype]]이 다른 객체를 참조하며 연결된 탐색 경로이다. 즉, 상위 객체를 따라 올라가는 검색 경로가 프로토타입 체인

> 자바스크립트의 프로토타입 체인에는 끝이 있음!!!! 바로 NULL이다. 모든 객체의 프로토타입은 결국 Object.prototype이고 그 상위는 null이 된다. 왜 그런걸까? JS 초기 철학이 어떤 값이든 객체처럼 다를 수 있고, 동적으로 프로퍼티를 추가할 수 있고, 공통 기능을 재사용할 수 있게 하자이기 때문. 그래서 우리가 `"abc".toUpperCase()`, `true.toString()` 이런식으로 쓸 수 있는거임

Q. 프로토타입을 변경하면 무슨일이 일어날까? <br />
A. 상속이 깨진다?

> 이건 2개의 상황으로 나뉠 수 있다

```javascript
function A() {}
const a1 = new A();

A.prototype = { y: 2 };
const a2 = new A();
```

- a1 인스턴스는 예전 prototype을 그대로 참조하기에 새 prototype을 모름
- a2 인스턴스는 변경된 prototype 참조

> 이때는 상속 관계가 분리된다는 표현이 맞다 = 서로 다른 부모를 갖게 되었기 때문

```javascript
const obj = {};
Object.setPrototypeOf(obj, { a: 1 });
```

- obj의 프로토타입 체인이 변경됨
- 기존 상속 구조가 바귐

> 이 경우는 실행중 상속 경로가 바뀐 것이 맞는 표현

Q. `__proto__`와 prototype의 차이 <br />
A. 프로퍼티는 숨겨진 속성 프로토타입 안에 있는 항목이고, 프로토타입은 생성자 함수의 객체를 프로토타입이라고 칭한다?

> `__proto__` 은 객체가 실제로 가지고 있는 부모(프로토타입) 링크 <br /> prototype은 생성자 함수가 가진 미래 인스턴스들에게 물려줄 프로토타입 객체 (함수가 가지는 프로퍼티임 객체가 가지지 않음)

Q. 콜백(callback) 함수란 무엇이고, 왜 비동기 처리에 자주 쓰일까? <br />
A. 특정 동작 또는 행위가 완료 된 이후에 실행되는 작업 의미하며 비동기 처리에서 요청을 보내고 콜백함수를 통해서 받은 응답을 처리하기 용이하기 때문이다 <br />
근데 이거 말이 애매하지 않아요? 대부분 자료에서 이해하기 편하라고 비동기는 작업 완료를 기다리지 않은 채 다음 작업을 계속 진행할 수 있는 방식,
동기는 이전 작입이 끝나야 다음 작업이 실행되는 방식으로 표현하는데, 결국 콜백 함수도 동기적으로 실행 되는거잖아요?
스택에 A, B, C 작업이 쌓여있고, A가 실행되는데 내부에 비동기 작업이 있다면 A는 콜백 등록이 되고 스택에서 빠진 다음 B가 실행이 될것인데 여기서 A의 콜백 응답이 왔다면? 스택은 무조건 1개밖에 실행을 못하니까 결국 C 작업이 밀리는거면 동기 아닌지...?

> 콜백 실행 자체는 동기가 맞음! 다만 콜백을 언제 실행할지 결정하는것이 비동기임. 콜백의 핵심은 스택에 즉시 올라오지 않는 것.<br /> 비동기 = 순서가 뒤로 밀릴수 있는것 <br /> 콜백실행 = 밀렸더라도 올라온 순간은 동기

Q. 동기(synchronous)와 비동기(asynchronous)의 차이를 코드 예시로 <br />
A.

```javascript
// 동기
fetch(apiUrl).then((resp) => fetch(apiUrl, resp).then(() => /* ... */))

// 비동기
const data1 = await fetch(apiUrl)
const data2 = await fetch(apiUrl)
if(data1 || data2) console.log(data1, data2);
```

> 완전 틀림...

```javascript
// 동기
function syncTask() {
  console.log("a");
  for (let i = 0; i < 1e9; i++) {}
  console.log("B");
}
syncTask();
console.log("C");

// 비동기
console.log("A");
setTimeout(() => console.log("B"), 0);
console.log("C");
```

Q. 이벤트 루프(Event Loop)의 역할? <br />
A. 프로세스를 마치 비동기처럼 실행시켜주는 역할. 콜백함수가 스택에 들어오면 큐로 옮겨지고 이벤트 루프에 의해 틱이 들어오면 스텍으로 옮겨지는 역할을 한다

> 콜백함수는 최초에 스택으로 들어오지도 않음. 이벤트 루프는 콜 스택이 비는 시점을 감시하며, 태스크 큐에 쌓여있는 작업을 콜 스택으로 옮겨 실행시키는 역할. 이 과정 덕분 JS는 싱글 스레드임에도 비동기 처리가 가능해진다

Q. Call Stack, Web APIs, Task Queue (Callback Queue), Microtask Queue의 관계를 설명 <br />
A. 콜스택은 자바스크립트 코드가 실행되는 부분, Web APIs는 브라우저에서 처리하는 스레드, Task Queue는 api 응답..?, microtask queue는 제일 후순위 톨백..?

> 완전 틀림

1. 콜 스택

- JS 코드가 실행되는 공간
- 함수 호출 -> 스택 push
- 함수 종료 -> 스택 pop

2. Web APIs

- 브라우저가 제공하는 비동기 작업 처리 영역 (타이머라면 카운트 작업 같은...)
- setTimeout, DOM 이벤트, fetch/AJAX, addEventListener, Promise의 reslove(정확히는 내부 엔진)
- JS 엔진은 이곳에 작업을 맡기고 즉시 스택에서 빠짐

3. Task Queue (매크로 대스크 큐)

- Web API에서 완료된 **콜백 함수**가 들어오는 큐
- setTimeout 콜백, setInterval 콜백, DOM 이벤트 콜백, AJAX 콜백

4. Microtask Queue

- 가장 높은 우선순위의 큐
- 태스크 큐보다 먼저 실행됨
- Promise 기반 비동기 작업이 대기하는 최우선 큐
- Promise.then, async/await 뒤의 코드, queueMicrotask, MutationObserver

5. 이벤트 루프 역할

- 스택이 비는 순간, 마이크로태스크 큐 먼저 모두 실행 => 태스크 큐에서 하나 실행 -> 이 과정 반복

Q. setTimeout, Promise, async/await이 동시에 있을 때 어떤 순서로 실행 <br />
A. setTimeout -> Promise -> async/await

> Promise, async/await -> setTimeout

Q. callback 함수 vs promise vs async/await <br />
A. 비교를 물어보는걸까요? 아님 정의...?
callback은 응답 또는 이벤트핸들러 등 틱이 왔을때 실행할 함수를 의미하고, promise는 약속된 것을 반환해주는 메서드, async/await도 비동기 처리를 해주는 문법으로 es6부터 도입

> 콜백 함수는 비동기 작업이 끝났을때 실행할 함수를 인자로 전달하는 방식, Promise는 비동기 작업의 상태를 값처럼 다를 수 있게 만든 객체, async/await은 Promise 기반 비동기 코드를 동기 코드처럼 작성할수 있게 하는 문법(Promise를 읽기 좋게 쓰는 문법적 설탕)

Q. async/await를 사용할 때 try...catch가 필요한 이유 <br />
A. 요청을 보내고 난 후 응답이 도착하지 않아도 에러를 발견하고 처리하기 위해서

> await된 Promise가 reject 상태(에러 발생)가 되면 await은 에러를 throw한다. try/catch는 이 reject된 에러를 처리하기 위한 구문이다
> throw는 지금 함수 실행을 멈추고 가장 가까운 catch로 점프하라는 신호

Q. Node.js 환경에서 비동기 처리는 브라우저와 어떻게 다를까 <br />
A. 모르겠다

> 브라우저는 여러 비동기 작업을 Web APIs가 처리하고, Node.js는 libuv라는 C 기반 라이브러리가 처리한다. 둘 다 싱글 스레드 이벤트 루프구조이지만, 비동기 작업을 처리하는 백그라운드 주체가 다르다

Q. 비동기 코드에서 race condition이 생길 수 있을까 <br />
A. 모르겠다

> race condition이란 순서 경쟁 때문에 잘못된 결과가 나오는 상황을 의미한다
> 자바스크립트는 비동기 작업의 완료 타이밍이 예측 불가능하기 때문에 충분히 race condition이 발생할 수 있다
