# 7주차

### React 이론

Q. 리액트의 렌더링 과정 <br />
A. 대상 DOM 노드와 함께 createRoot를 호출한 다음 해당 컴포넌트로 render 메서드를 호출해서 렌더링 한다 <br />
즉, HTML에서 root란 id를 가진 DOM 요소 안에 렌더링 엔진을 통해 원하는 컴포넌트를 렌더링한다.

> 초기 렌더링에서 React는 루트 컴포넌트를 호출하고, 이후 렌더링에서는 React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출한다. <br/> 이 단계에서 업데이트 된 컴포넌트가 컴포넌트를 반환하면 반환된 컴포넌트 렌더링 하고 등등... 재귀적 단계가 지속된다. [링크](https://ko.react.dev/learn/render-and-commit)

Q. React는 왜 선언적일까요? <br />
A. 컴포넌트는 순수하게 유지 해야하기 때문에? 그래서 컴포넌트도 모두 함수 선언문인거 아닌지? [링크](https://ko.react.dev/learn/keeping-components-pure)

> React에게 컴포넌트 로직에서 무엇을 렌더링할지 지시하면 React는 이를 사용자가 최적으로 볼 수 있도록 알아서 처리한다 [링크](https://ko.react.dev/reference/rules#react-calls-components-and-hooks) <br /> 즉, UI가 최종적으로 어떤 모습이어야 하는지를 선언하는 방식 (명령형 방식이 아님)

Q. Virtual DOM? <br />
A. React가 변경된 컴포넌트를 추적하기 위한 가상의 DOM 트리

> UI를 메모리에 가상 DOM 구조로 표현하고, 새로운 트리와 이전 트리를 비교하여 변경된 부분만 실제 DOM에 반영하는 방식이다 [링크](https://ko.legacy.reactjs.org/docs/faq-internals.html) <br /> 최근엔 virtual dom 단어보단 렌더 트리 -> 비교 -> 커밋 이란 단어로 virtual dom 개념을 설명하는 추세인 것 같다

Q. React의 모든 업데이트가 “불변성”을 전제로 하는 이유? <br />
A. 정확히는 React가 불변성을 강제하는 것은 아니고 state와 props에 대해 이야기한 공식문서를 살펴보면 state, props는 불변이며 직접 변경하지 말라고 이야기한다. 즉, 변경하고 싶으면 해당 값을 복사해서 새로운 props를 전달하거나, setter 함수(useState)를 통해 업데이트 하라고 권장한다. [링크] (https://ko.react.dev/reference/rules/components-and-hooks-must-be-pure#props-and-state-are-immutable) <br />
왜 불변성을 권장 하냐면 애플리케이션이 일관성 없는 출력을 생성하게 될 수 있기 때문이다. 그로인해 디버깅이 어려워진다. 리액트의 렌더링 규칙상 state같은 경우 state 변수를 직접 변경하면 UI 리렌더링이 발생하지 않아 이전 UI를 보게된다. [링크](https://ko.react.dev/learn/updating-objects-in-state#why-is-mutating-state-not-recommended-in-react)

> React가 불변성을 권장하는 이유는 렌더링 규칙 + 변경 감지 방식 때문이다. React는 객체 내부가 바뀌었는지를 감지하는 것이 아닌 오직 값 자체가 변경 되었는지(참조 비교=메모리 주소 비교)만 감지한다 [링크](https://ko.react.dev/learn/updating-objects-in-state) 따라서 기존 상태를 직접 업데이트하면 참조가 변하지 않기 때문에 React는 변경을 감지하지 못해 리렌더링이 발생하지 않는다. 이러한 버그는 추적하기 어렵게 만든다. 또한, React의 최적화 기능을 쓰려면 불변성을 지켜야지 가능하다. 불변성을 지키면 얕은 비교만으로도 변경 여부를 판단할 수 있는데 (이전 객체와 새 객체의 key별로 참조값 비교만 수행) state를 직접 변경할 경우 변화가 없다고 판단하기 떄문에 React의 최적화 기능들이 무시된다. (얕은 비교는 O(1)이다)

Q. 상태란 무엇일까요? <br />
A. React에서 변경 추적이 가능한 값을 저장하는 읽기 전용 변수

> 정확히는 읽기 전용이 아닌, state는 읽기 전용처럼 다뤄야한다라는 표현이 맞다. 또한 추적이라기 보다는 변경 요청이 들어오면 새로운 상태 스냅샷을 만들고 그 상태 기반으로 렌더링을 하는 개념. 즉 React의 state는 컴포넌트 렌더링에 영향을 주는, 시간에 따라 변할 수 있는 데이터를 의미한다. 상태가 변경되면 React는 컴포넌트를 다시 렌더링하여 UI를 최신 상태와 동기화한다 [링크](https://ko.react.dev/learn/state-a-components-memory)

Q. 상태관리 툴을 사용하는 이유? <br />
A. React는 상위 컴포넌트에 선언한 state를 하위 컴포넌트에게 전달하려면 차례대로 props를 통해 전달하는 방법 또는 global하게 사용할 상태라면 context를 통해 전달하는 방법밖에 없다. props로 전달하는 방법은 props 드릴링으로 사용하지 않을 컴포넌트까지 차례대로 내려줘야하다보니 디버깅이 어렵게 될 수도 있으며, context같은 경우에도 root 컴포넌트에서 provider를 감싸줘야하기 때문에 provider가 많아질 경우 많은 중첩이 일어나 가독성이 떨어질 수 있다

> 애플리케이션 규모가 커질수록 컴포넌트 간 상태 공유, 업데이트 흐름, 비동기 데이터 관리가 복잡해지기 때문에 상태를 한 곳에서 예측 가능하게 관리하기 위해 상태관리 툴을 사용한다. 상태관리 툴은 서로 먼 컴포넌트들이 같은 데이터를 공유해야할때 유용하며, Redux처럼 상태변경 로직을 중앙화해서 관리가 가능하고, 비동기 요청 상태인 loading, error, data를 체계적으로 관리할 수 있으며, Context은 Provider 하위 전체를 리렌더링 시키지만 상태관리 툴을 이용하면 필요한 컴포넌트만 선택적으로 리렌더링이 가능하다

> 비동기 요청 상태관리가 왜 이득일까 싶었다. 맨 첨엔 단순하게 1차적으로 공통 hook을 만들면 되지 않나? 싶었지만, 공통 hook을 만든다고 해도 컴포넌트마다 독립된 state를 만들기에 어쩌면 한 페이지에 같은 비동기 로직이 3번 이상 발생할 수도 있다 (3번 fetch 등...) 근데 React Query같은 상태관리 툴을 쓴다면 이 3번의 fetch를 1번 fetch로 하게끔 해주고, 모든 컴포넌트에 공유도 되고 캐싱 등등 기능이 있기에... 그래서 사용하는 것이다

Q. 리랜더링? <br />
A. 리렌더링이란 React state에 변경 요청이 들어오면 현재 state에 맞게 UI를 업데이트 한다.

Q. Reconciliation? reconciliation의 단계 <br />
A. 렌더링 과정과 겹치는 내용 아닌가?

> Reconciliation(재조정)이란 React가 이전 렌더 트리와 새 렌더 트리를 비교해서 실제 DOM에 최소한의 변경만 적용하는 과정 [링크](https://react.dev/learn/preserving-and-resetting-state)<br /> 재조정 단계 <br /> 1. 렌더 단계: 컴포넌트 함수 호출 -> JSX -> render tree 생성 <br /> 2. 비교 단계: 이전 렌더 트리와 새료운 렌더 트리 비교 <br /> 3. 커밋 단계: 실제 DOM에 변경사항 적용 -> 바뀐 부분만 업데이트 됨

Q. render 페이즈? / commit 페이즈? <br />
A. 위 질문과 같은 내용 아닌가?

> render 단계: 컴포넌트 호출 -> JSX 실행 -> render tree 생성 -> 변경된 속성 계산 -> 변경된 정보 준비 (DOM 수정 안함) <br /> commit 단계: 변경 사항을 실제 DOM에 반영 -> 브라우저 repaint/reflow 진행 -> effect 실행

Q. 리랜더링 vs reconciliation <br />
A. 이게 비교 대상으로 나올 수 있는 질문인가요? 리렌더링의 단계가 재조정(reconciliation)인게 아닌지...

> 정확히는 재조정이란 비교 과정을 의미한다 [링크](https://react.dev/learn/preserving-and-resetting-state) React 공식 문서도 reconciliation를 검색하면 React가 어떤식으로 컴포넌트를 비교하는지에 대해서만 설명하고 있다. 리렌더링(렌더링)이란 개념에 재조정이 포함된 것이다 <br /> 렌더링: 트리거 -> 렌더 단계 -> Reconciliation(재조정, 비교단계) -> 커밋 단계

Q. setState를 여러번 호출하면? <br />
A. 업데이트가 여러번 호출한다? 렌더링 단계에서 업데이트 해버리면 이전 변경사항이 반영돼서 리렌더링이 안될 수도 있다? 동시성 문제가 발생할 수 있다?

```javascript
// 애초에 질문을 잘 못 이해한 것 같다. 나는 질문을 딱 보고선 당연히 아래와 같은 코드에 대한 질문이지 않을까란 생각을 했다
const onClick = () => {
  setCount(count + 1);
};

// 근데 위 상황에 대한 질문이 아닌 것 같고, 아래와 같은 상황이지 않을까 싶다
const onClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  setCount(count + 1);
}; // 위 같은 상황이면 결과가 3이 아닌 1로 나올것이다

// 위 상황을 피하고 원하는 값이 출력되게 하려면
const onClick = () => {
  setCount((prev) => prev + 1);
  setCount((prev) => prev + 1);
  setCount((prev) => prev + 1);
}; // 이렇게 작성해주면 리액트가 최신 계산 결과를 순차적으로 전달해주기에 업데이트 된 최신값에서 +1 추가가 가능해진다
```

> React의 state는 렌더 시점에 캡처된다 (클로저 개념) 그렇기 때문에 onCLick에 전달된 state값 (여기서 count가 0이라면) 이 값이 고정이기에 onClick 내부에서 count 값을 읽으면 항상 0이다. 즉 같은 값(0인 count)를 계속 사용하는 것. 그러니 원하는 결괏값을 출력할수 없게된다. 추가적으로 React 18부터 자동 배칭이 생겼다 [링크](https://ko.react.dev/blog/2022/03/29/react-v18?utm_source=chatgpt.com#new-feature-automatic-batching) 그래서 setState를 여러번 호출해도 그 여러번에 대한 리렌더링이 매번 발생하지 않고 업데이트를 하나의 렌더링 사이클로 묶어 실행한 다음 1번의 리렌더링만 발생하게끔 해준다 (정확히는 18 이하에서 이벤트 핸들러 안에서는 배칭을 해줬으나, setTimeout, Promise.then 등등에서 안해줬던 배칭을 18부터 해주기 시작)

Q. setState는 동기? 비동기? <br />
A. 동기이다

내가 혼동한 부분. setState를 동기라고 생각했던 이유는 setState의 내부 로직이 동기적이라고 생각했기 때문이다. 리렌더링이 끝나야지만이 최종 결과물을 볼 수 있어서 때문? 결괏값이 반영되기까지 코드가 순차적으로 실행되어야하니까? <br /> 근데 setState의 호출 시점 에서만 봤을땐 setState를 호출했다고 해서 다음 코드가 실행되지 않는게 아니다 setState 호출 바로 다음 console.log 코드를 실행하면 이전 값으로 찍힌다. 즉, 한마디로 state 업데이트가 비동기적으로 일어난다. <br /> 그러면 setState도 다른 비동기 함수처럼 Promise를 반환 받을 수 있어야할 것 같은데 아니다.... 나중에 실행되는 코드가 아니다...! 그럼 동기 함수인가? 싶은데... setState 내부 로직은 JS 기준으로 동기는 맞다. 왜냐면 즉시 실행 후 return한 다음, 그 다음 프로세스로 넘어간다. setState는 React에게 업데이트 할게 있다라는 요청만 보낼뿐인데 이 과정에서 state 값이 바뀌는게 아니다. state는 나중에 React 렌더링에서 비동기적으로 변경된다. 근데 또 헷갈리는데..

```javascript
const onClick = () => {
  setCount((prev) => prev + 1);
  setCount((prev) => prev + 1);
  setCount((prev) => prev + 1);
};
```

위 코드를 보면 결국 반환값이 3이니까 동기 아니야? 싶었는데, 계산 로직은 동기이지만, onClick 내부에서는 아직 state는 0이다. 그리고 나중에 리렌더링이 일어나면 그때 state가 업데이트 되어 3이 나오는 것이다. 즉, **setState 함수 호출(함수 자체)은 동기이지만, 업데이트 반영은 비동기다** 이 말이 맞는 것 같다.

그리고 내가 헷갈렸던 리렌더링이 끝나야지만이 최종 결과를 볼 수 있으니까 동기다란 표현도 잘못 이해한 표현이다. 나는 setState() -> (즉시) -> 렌더 -> 커밋 -> 변경 이렇게 이루어진다고 생각했다. <br />
그러나 실제 리액트 동작은 setState() -> 끝(return) -> 다음 tick or frame에서 -> 렌더링 시작 -> 렌더링 과정 이렇게 이루어지며 렌더링 과정도 setState와 함께 발생하는 과정이 아닌 독립된 파이프라인에서 실행된다. <br />
또한, 렌더링은 비동기이다. 왜냐면 중간에 중단될 수도 있고, 비동기 스케줄링 기반 UI 업데이트라고 한다.

Q. hooks 이란? <br />
A. React에서 제공하는 함수...? 리액트가 제공하는 모든 hook에 대한 설명 나열인걸까요 [링크](https://ko.react.dev/reference/react/hooks)

Q. 리액트 hook의 종류와 각각 무엇인지? <br />
A.

1. 상태 값을 저장하고 업데이트할 수 있는 state hook
2. 먼 컴포넌트에 값을 전달할 수 있느 context hook
3. 값을 캐싱할 수 있는 useMemo
4. 함수를 캐싱할 수 있는 useCallback
5. dom을 직접 조작하거나 React가 관리하는 외부 값?을 조작하기 위해 쓸 수 있는 useRef
6. 컴포넌트가 마운트된 이후 사용할 수 있는 effect hook
7. 그 외 직접 만든 custom hooks

Q. JSX란? 어떻게 JSX가 동작하는 걸까요? <br />
A. 리액트에서 만든 html 코드를 포함한 자바스크립트 실행 문법 [링크](https://ko.react.dev/learn/writing-markup-with-jsx?utm_source=chatgpt.com)

> 자바스크립트를 확장한 문법으로 자바스크립트 파일을 HTML과 비슷하게 마크업할 수 있도록 해준다. JSX는 React에 속한 개념이 아니고, 별개이며 각각 사용할 수 있다. JSX는 트랜스파일러에 의헤 React.createElement() 호출로 변환되고 React 엘리먼트(가상 돔) 생성 후 최종 렌더링에 반영된다 <br/> 근데 이건 옛날 방식이고, 지금은 React.createElement 대신 jsx/jsxs/jsxDEV 같은 함수로 변환된다 [링크](https://legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html?utm_source=chatgpt.com)

```javascript
// 아래와 같이 트랜스파일이 되고
_jsx("div", { className: "box", children: "Hello" });

// 이 코드는 실행하면 아래와 같이 됨
{
  $$typeof: Symbol(react.element),
  type: "div",
  key: null,
  ref: null,
  props: { className: "box", children: "Hello" }
}
```

Q. react와 react-dom이 나뉜 이유? <br />
A. 모른다

> React = UI를 설명하는 엔진(브라우저에 종속되지 않음) <br /> ReactDOM = 브라우저 DOM에 렌더링하는 구현체 [링크](https://stackoverflow.com/questions/34114350/react-vs-reactdom?utm_source=chatgpt.com) <br />
> 리액트가 처음 출시될때부터 목표는 어느 플랫폼에서나 UI를 만들 수 있는 라이브러리였던것, 그래서 만약 React DOM이 React 일부로 들어가 있었다면 React Native를 만들 수 없었을 것이다.
