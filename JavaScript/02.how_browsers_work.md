# 브라우저의 동작 원리

브라우저는 멀티 스레드이며, 별도의 스레드와 프로세스에서 각각의 필요한 작업들을 수행한다.

그러나 브라우저의 핵심 기능인 웹 페이지를 서버에 요청하고 서버의 응답을 받아 브라우저에 표시하는 기능은 메인 스레드에서 실행된다.

### 1. 탐색

탐색은 웹 페이지를 로딩하는 첫 단계이며, 사용자가 주소창에 URL을 입력하거나, 링크를 클릭하거나, Form을 제출하는 등의 동작을 통해 최초로 요청을 보낼때 발생한다.

사용자가 한번도 접근한 적 없는 웹 페이지라면, 아래와 같이 작업이 수행된다.

1. DNS 조회
2. 브라우저와 서버간에 TCP 소켓 연결 (TCP 3-way handshake)
3. HTTPS 보안 연결 (TLS 협상)

이미 방문한 페이지라면 캐싱된 DNS 결과나 TCP/TLS 연결을 재사용한다.

### 2. 응답

브라우저는 서버로부터 한 번 연결이 성립되고 나면, 사용자 대신 초기 HTML, CSS, Javascript, 이미지 파일 등을 요청해서 응답 받는다.

이 과정도 TCP 위에서 동작하기 때문에 네트워크 상태에 따라 슬로우 스타트 알고리즘에 의해 데이터 요청/전송 속도를 제어한다.

### 3. 구문 분석 (파싱)

브라우저는 수신된 정보를 구문 분석하기 시작한다. 구문 분석은 렌더링 엔진이 수행하며, DOM이나 CSSOM으로 바꾸는 단계이다.

#### 3-1. DOM 트리 구축

HTML을 처리하여 DOM 트리를 만든다. DOM 트리는 HTML 엘리먼트로 이루어진 트리를 의미한다.

<img src="https://yozm.wishket.com/media/news/1338/image004.png" width="600"></img>

DOM 노드의 개수가 많아질수록, DOM 트리를 만드는데 시간은 오래걸리게 된다.

HTML 파서는 구문 분석중 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 그 후 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 만약, 자바스크립트 분석과 실행 순서가 중요하지 않고 스크립트가 프로세스를 막지 않도록 하려면 `async` 속성 또는 `defer` 속성을 추가하는게 좋다.

#### 3-2. CSSOM 구축

CSS를 처리하고 CSSOM 트리를 만든다. DOM과 같이 트리 구조다. 재귀적으로 계산하면서 각 요소의 최종 스타일을
우선순위에 맞게 계산을 진행한다. (캐스케이드 방식)

#### 3-3. 그 외 작업

브라우저는 접근성 트리도 구축한다. 보조 장치는 이 트리를 이용해 내용을 분석하고 해석한다. 접근성 객체 모델(AOM)이라고 부르며, AOM이 만들어지기 전까지 화면 리더기는 콘텐츠에 접근할 수 없다.

### 4. 렌더

CSSOM과 DOM 트리는 구문 분석 되는 과정에서 생성되고 렌더 트리로 합성된다. 렌더 트리는 기본적으로 화면에 나타나는 요소들을 결정하는 트리다. 그렇기에 화면에 그려지지 않는 요소들은 트리에 나타나지 않는다.

<img src="https://yozm.wishket.com/media/news/1338/image007.png" width="600"></img>

### 5. 레이아웃 또는 리플로우

렌더 트리 구성이 끝나면 이 기반으로 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행한다.

레이아웃은 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정하는 프로세스이다. 리플로우는 레이아웃 이후에 있는 페이지의 일부분이나 전체 문서에 대한 크기나 위치에 대한 결정이다.

처음 노드의 사이즈와 위치가 결정되는 레이아웃 과정을 거치고, 이 후에 노드의 크기와 위치를 다신 계산해야하는 상황이 오면 리플로우라고 부른다.

레이아웃, 리플로우는 비싼 연산이다. 노드 하나만 바뀌어도 연관된 부모/자식 노드까지 다시 계산 해야할 수도 있기 때문이다. 그렇기에 레이아웃, 리플로우를 최소화 하는게 렌더링 최적화의 핵심이다.

### 6. 페인트

마지막 단계로 각 노드를 화면에 페인팅한다. 레이아웃 단계에서 계산된 각 박스를 실제 화면의 픽셀로 변환한다. 결과적으로 각 노드가 화면에 어떻게 보일지 픽셀 단위의 데이터가 만들어진다.

모든 것을 한 장의 캔버스에 그리면 성능이 떨어질 수 있다. 그래서 브라우저는 일부 레이아웃 트리의 요소를 레이어로 분리할 수 있다. 해당 요소를 CPU의 메인 스레드에서 GPU 레이어로 격상하는 것은 페인트 및 리페인트의 성능을 높인다. GPU 레이어로 승격되는 요소로는 `<video>`, `<canvas>`, `opacity`, `transform` 등이 있다.
레이어는 성능을 향상 시키지만, 메모리 관리 측면에서 봤을때는 비싼 작업이기에 웹 성능을 최적화 전략으로 과도하게 쓰이지 않아야 한다.
