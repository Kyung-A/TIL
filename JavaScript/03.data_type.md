# 데이터 타입

자바스크립트는 동적 타입 언어이다. 변수의 타입 지정 없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정(타입 추론)된다. 따라서 같은 변수에 여러 타입의 값을 자유롭게 할당 할 수 있다.

### 1. 데이터 타입이란?

데이터 타입은 프로그래밍 언어에서 사용할 수 있는 데이터의 종류를 의미한다.
데이터 타입은 데이터를 메모리에 저장할 때 확보해야 하는 메모리 공간의 크기와 할당할 수 있는 유효한 값에 대한 정보, 그리고 메모리에 저장되어 있는 2진수 데이터를 어떻게 해설할 지에 대한 정보를 컴퓨터와 개발자에게 제공한다.

자바스크립트의 데이터 타입은 원시 타입과 객체 타입(참조 타임)으로 나누어진다.

`원시 타입`

- number
- string
- boolean
- null
- undefined
- symbol
- bigInt

`객체 타입(참조 타입)`

- object

---

### 2. 원시 타입

원시 타입의 값은 언어의 최하위 수준에서 직접 표현되는 변경 불가능한 값을 정의한다.

#### 2-1. number

자바스크립트는 다른 프로그래밍 언어와 다르게 int, long, float, double등 과 같은 다양한 숫자 타입 제공이 아닌 하나의 숫자 타입만 존재한다.

숫자 타입의 값은 배정밀도 64비트 부동소수점 형을 따른다. 2진수, 8진수, 16진수 리터럴은 메모리에 동일한 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 이들 값을 참조하면 모두 10진수로 해석한다.

추가적으로 3가지 특별한 값들도 표현할 수 있다

- `Infinity` : 양의 무한대
- `-Infinity` : 음의 무한대
- `NaN` : 산술 연산 불가

자바스크립트에서의 `Infinity`는 일반 수(number 타입의 한 값)이지 수학적 게념의 끝없는 크기를 완벽히 표현한 의미는 아니다.

`NaN`는 산술 연산의 결과를 숫자로 표현할 수 없을때를 의미한다.

```javascript
const nan = 1 * "str"; // NaN
```

위 예시와 같은 연산을 실행할 경우 NaN이 출력된다.

또한, 자바스크립트는 `0`과 `-0`이라는 두 종류의 0이 존재한다. 자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설헝할 수도, 설정하지 않을 수도 있기 때문이다. 그래서 0은 +0으로 표현 가능하다.

다만, IEEE 754와 자바스크립트 사양에서 비교 연산에서는 `+0 === -0`은 `true`로 동일한 값으로 간주한다. `-0`을 따로 둔 이유는 극한 계산이나 그래프 방향성을 다룰떄 유형하기에 존재한다. `Object.is`를 사용하면 엄격한 구분이 가능하다.

#### 2-2. string

문자열 타입은 텍스트 데이터를 나타내는데 사용한다. 문자열은 작은따옴표나 큰타옴표, 백틱으로 감쌀 수 있다.

백틱으로 감싼 문자열 중간에 표현식 `${...}`을 삽입해주면 코드를 삽입할 수 있다.

```javascript
console.log(`result ${1 + 3}`); // 'result 4'
```

이런 방식을 템플릿 리터럴이라고 부른다.

자바스크립트의 문자열은 변경 불가능하다. 이것은 한 번 문자열이 생성되면, 그 문자열을 변경할 수 없다는 것을 의미한다.

```javascript
let str = "Hi";
str[0] = "L"; // Error!
```

이와 같이 변경하려고 할 경우 에러가 반환된다

문자열을 변경하려는 방식이 아닌 재할당 하는 방식으로 해야한다.

```javascript
let str = "Hello";
str = "world";
```

첫번째 구문이 실행되면 메모리에 문자열 "Hello"가 생성되고 식별자 str은 메모리에 생성된 문자열 "Hello"의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 "Hello"을 수정하는게 아니라 새로운 문자열 "world"를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 "Hello"와 "world"는 모두 메모리에 존재하고 있다. 자바스크립트 엔진은 "Hello"를 더이상 참조하는 변수가 없다면 가비지 컬렉터가 주기적으로 스캔하면서 "Hello"를 수거한다.

#### 2-3. boolean

불리언 타입의 값은 논리적 참, 거짓을 타나내는 `true`와 `false`뿐이다.

비어있는 문자열과 `null`, `undefined`, 숫자 `0`은 `false`로 간주된다.

#### 2-4. null

null 타입의 값은 null이 유일하다.

null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 함수 호출이 되었으나 유효한 값을 반환할 수 없는 경우에도 명시적으로 null을 반환하기도 한다.

`typeof` 연산자로 null 값을 연산해보면 null이 아닌 object가 나온다. 이는 자바스크립트의 설계상의 오류다.

#### 2-5. undefined

undefined 타입의 값은 undefined가 유일하다. 선언 이후 값을 할당하지 않은 변수는 undefined 값을 가진다. 이는 자바스크립트 엔진이 undefined로 초기화하기 때문이다.

```javascript
let foo;
console.log(foo); // undefined
```

개발자가 의도적으로 변수의 값이 없다는 것을 명시하고 싶은 경우에는 undefined보다 null로 할당하는 것이 본래의 취지에 더 맞다. 만약 undefined로 명시할 경우 JSON 직렬화에서 undefined는 아예 제외되기에 DB, 네트워크 통신과 호환성을 생각하면 null이 더 안전하다.

#### 2-6. symbol

심볼은 변경 불가능한 원시 타입의 값이다. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 값이다.

```javascript
const key = Symbol("key");
console.log(typeof key); // symbol

let obj = {};
obj[key] = "value";
console.log(obj[key]); // value
```

보통 라이브러리 내부에서 은닉된 키를 만들때 자주 사용된다.

```javascript
const USER = {
  id: 1,
  name: "Jun",
};

USER["id"] = 999;
```

위 예시와 같이 `id`라는 문자열은 누구나 쓸 수 있으니까, 전역으로 충돌 위험이 있다.

그러나 심볼을 쓰면 같은 설명을 줘도 항상 새로운 고유값이 생성된다.

```javascript
const ID = Symbol("id");
const OTHER_ID = Symbol("id");

console.log(ID === OTHER_ID); // false

const USER = {
  name: "Jun",
  [ID]: 12345,
};

console.log(USER[ID]); // 12345
console.log(USER[OTHER_ID]); // undefined
```

React 내부에서는 React 엘리먼트라는 고유 마커를 붙이기 위해 앨리먼트 객체에서 심볼을 사용한다.

```javascript
const el = <div className="box" />;

// React 내부
const el = {
    $$typeof: Symbol.for("react.element"),
    type: "div",
    key: null,
    ...
};

// 만약 위와 같이 선언하지 않고 그냥 문자열로 생성한다면?
const fakeEl = {
    $$typeof: "react.element",
    type: "div",
    key: null,
    ...
};

// React 내부 동작 예시
const REACT_ELEMENT_TYPE = Symbol.for("react.element");

function isReactEl(obj) {
    return obj && obj.$$typeof === REACT_ELEMENT_TYPE;
}

console.log(isReactEl(el));     // true
console.log(isReactEl(fakeEl)); // false
```

심볼을 사용하지 않고 문자열을 사용하게 된다면 외부 코드가 흉내내는 가짜 객체를 쉽게 만들 수 있게되며 React 내부 로직이 속아 넘어갈 수 있게 된다.

#### 2-7. bigInt

number으로 표현할 수 없는 매우 큰 정수를 다루기 위한 타입이다. 표준으로 채택된지 얼마 안된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있다.

암호 관련 작업같이 아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때는 이런 큰 숫자가 필요하다.

```javascript
const bigInt = 12312314325454654735424131233n;
```

정수 리터럴 끝에 n을 붙이면 만들 수 있다.

---

### 3. 객체 타입 (참조 타입)

객체는 데이터와 그 데이터에 관련한 동작을 모두 포함할 수 있는 개념적 존재이다. 이름과 값을 가지는 데이터를 의미하는 프로퍼티와 동작을 의미하는 메소드를 포함할 수 있는 독립적 주체이다.

자바스크립트는 객체 기반의 스크립트 언어로서 자바스크립트를 이루고 있는 거의 모든 것이 객체이다. null, undefined를 제외한 모든 원시 타입에는 원시 값으로 작업하는데 유용한 메소드를 제공하는 해당 객체 래퍼 타입이 있다. 원시 값 속성에 접근하면 자바스크립트는 값을 해당 래퍼 객체로 자동으로 감싸주고 이 객체는 곧 삭제해버립니다.

래퍼 객체는 원시 타입에 따라 종류가 다양하다. `String`, `Number`, `Boolean`, `Symbol` 라고 부르며, 래퍼 객체 마다 제공하는 메소드 역시 다르다.
