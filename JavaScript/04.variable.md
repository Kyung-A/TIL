# 변수

변수란 값이 위치하고 있는 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 명명한 식별자이다.

변수는 `var`, `let`, `const` 키워드를 사용하여 선언하고 할당 연산자(`=`)를 사용해 값을 할당한다. 그리고 식별자인 변수명의 사용해 변수에 저장된 값을 참조한다.

```javascript
let score;  // 변수 선언
score = 80; // 값의 할당
score = 90l // 값의 재할당
score;      // 변수의 참조
```

### 변수의 선언

변수의 존재 목적을 쉽게 이해할 수 있도록 의미있는 변수명을 지정하여야한다.

변수명은 식별자로 불리기도 하며 명명 규칙이 존재한다.

- 반드시 영문자(특문 제외), 언더바(\_), 달러 기호($)로 시작하여야한다.
- 숫자도 포함 할 수 있으나 첫번째 시작 글자에 위치하면 안된다.
- 자바스크립트는 대/소문자를 구별한다.

참고로 예약어는 변수명으로 사용할 수 없다

```javascript
let let = 5;
let return = 5;
```

위와 같이 예약어를 사용하면 에러가 발생한다.

> `var` 키워드로 생성한 변수는 중복 선언이 가능하다. 이 외에도 `var` 키워드는 함수 레벨 스코프이기에 전역 변수로 등록되어 변수의 유효 범위가 넓어진다. 의도치 않은 재할당, 중복 선언이 가능해지는 상황이 발생할 수 있으며 디버깅에 어려움을 마주하게 된다. 따라서 `var` 키워드 사용은 지양하며, `let`, `const` 키워드를 사용하는 것이 좋다.

### 변수 호이스팅

```javascript
console.log(foo); // 1. undefined
var foo = 123;
console.log(foo); // 2. 123
{
  var foo = 456;
}
console.log(foo); // 3. 456
```

`var` 키워드를 사용하여 선언한 변수는 중복 선언이 가능하기 때문에 위 코드는 문법적으로 문제가 없다.

1에서의 변수 foo는 아직 선언되지 않았지만 에러 대신 undefined가 출력된다.

이 현상은 자바스크립트의 특징으로 모든 선언문은 호이스팅 되기 때문이다.

자바스크립트 엔진은 코드를 실행할 때 두 단계를 거친다.

1. 메모리 생성 단계

- 실행 컨텍스트를 만들고, 스코프 안의 변수, 함수 선언을 스캔
- `var`는 undefined로 초기화
- `let`, `const`는 TDZ(Temporal Dead Zone)에 들어가며 실제 초기화는 나중에 발생
- 함수 선언문은 전체 함수 객체로 미리 초기화

2. 실행 단계

- 코드를 위에서부터 한줄씩 실행
- 변수에 값이 할당되고 함수 호출이 이루어짐

호이스팅은 1단계인 메모리 생성 단계에서 일어난다.

`var` 키워드로 선언된 변수는 1번의 선언을 스캔하는 단계와 초기화 단계가 한번에 이루어진다. 즉, 스코프에 변수가 등록되고 변수는 메모리 공간을 확보한 후 `undefined`로 초기화한다. 따라서 변수 선언문 이전에 변수에 접근하여도 변수가 존재하기 때문에 에러가 발생하지 않는다.

`let`과 `const` 키워드의 경우 호이스팅 되지만, 일시적 사각 지대인 TDZ에 있기 때문에 초기화 전 접근시 `ReferenceError` 에러를 발생한다. 즉, 호이스팅 되지만 접근이 막혀 있어서 `var`처럼 보이지 않는 것 뿐이다.

자바스크립트 변수는 블록 레벨 스코프와 함수 레벨 스코프를 갖는다.

- 함수 레벨 스코프 : 함수 내에서 선언된 변수는 함수 내애세먼 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수, 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 불록 레벨 스코프 : 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

```javascript
function doSomething(someVal) {
  // Function scope
  typeof variable; // "undefined"

  if (someVal) {
    // Inner block scope
    typeof variable; // ReferenceError
    let variable;
  }
}

doSomething(true);
```

`doSomething` 함수는 함수 스코프이며, 내부에 있는 `typeof variable`가 `undefined`인 이유는 함수 시작 부분에 `let variable;` 과 같은 블록 스코프 선언이 없기 때문이다. 따라서 해당 코드는 바깥 스코프(전역)까지 확인하게 되고, 전역에도 선언된 `variable` 변수가 없으니 `typeof` 연산자는 결과로 `undefined`를 반환하게 된다.

> `typeof` 연산자는 특별 규칙 때문에 선언조차 안 된 식별자를 만나도 `ReferenceError` 대신 `undefined` 반환한다.

`if`문 블록 안에 있는 `let variable;`는 변수 선언이 되어있으나, 초기화 전에 참조가 되어 `ReferenceError` 에러가 발생하게 된다. `let` 키워드는 호이스팅 되지만 TDZ에 놓인다. 따라서 이 블록 안에서 `variable`은 이미 존재 하는 변수라고 간주되지만, 초기화 되기 전까지는 TDZ에 놓여있기에 접근 불가한데 먼저 참조를 해버리는 코드가 위치해서 참조 에러가 발생합니다.

> 이 경우에서 `typeof` 연산자는 변수 선언은 되었으나 잘못 된 참조를 한 것이기에 `ReferenceError`를 반환한다.
