# 중간점검

### Q. 자료형이 필요한 이유는?

A. 자료형, 실수형처럼 자료형마다 필요한 메모리 크기가 다르다. 자료형을 알아야지 정확히 몇 바이트를 할당해야 하는지 알 수 있다.

또한, 자료형을 통해 데이터 해석 방식을 정의할 수 있다. 똑같은 4바이트라도 `int`로 해석하면 정수, `float`로 해석하면 실수, `char[4]`로 해석하면 문자열로 보게된다. 자료형은 같은 비트를 어떻게 해석할지를 결정해준다.

자료형이 메모리에 기록되는 것은 아니고, 코드에서 자료형을 지정하면 컴파일러가 해당 정보를 바탕으로 CPU 명령어를 생성한다. CPU는 자료형을 직접 아는 것이 아니라, 컴파일러가 내려준 명령어에 따라 같은 메모리 값을 정수 연산용, 실수 연산용 등으로 다르게 처리한다.

컴파일러 과정에서 자료형을 알아야지 오류를 방지할 수 있다. 예를 들어 문자열과 숫자에 `+` 연산을 하려 하면 에러를 내주는 것처럼 (일부 언어 제외) 자료형은 잘못된 연산을 미리 막아준다.

---

### Q. 변수가 필요한 이유는?

A. 메모리에 저장된 값을 꺼내 쓰기위해 필요하다. 변수가 없다면 개발자가 직접 메모리 주소를 일일이 기억하고 접근해야하 하는데 사실상 `0x7ffeead...`를 기억하기란 쉽지 않다. 변수는 그 주소에 붙여 놓은 이름표 역할을 한다.

또한, 변수 이름을 통해 데이터가 무엇을 의미하는지 표현할 수 있어, 데이터의 식별자 역할도 한다.

---

### Q. 자료형 - 변수 - 메모리 동작 원리

A. 변수를 선언할때 자료형을 지정하면, 컴파일러는 해당 변수가 차지할 메모리 크기와 해석 방식을 결정한다. 컴파일러는 변수 이름을 해당 메모리 주소와 연결하고, 자료형에 맞는 CPU 명령어를 생성한다.

프로그램이 실행될 때 CPU는 이 명령어를 수행하여 메모리에 값을 저장하거나 꺼내 쓰며, 자료형에 따라 정수 연산, 실수 연산 등 서로 다른 방식으로 처리된다.

---

### Q. 스택과 힙의 차이

A. 프로그램이 메모리를 사용하는 두 가지 대표적인 영역으로 스택과 힙이 있다. 이 두가지의 차이점은 아래와 같다.

스택에 저장되는 값으로는 주로 원시 타입의 자료형 또는 짧게 쓰고 금방 사라지는 데이터가 저장된다. 컴파일러가 자동으로 관리하며 함수가 호출되면 스택에 공간이 할당되고, 함수가 끝나면 자동으로 해제되는 후입선출(LIFO) 구조이다. 관리가 자동이라 속도가 빠르고 안전하며 메모리 단편화가 이루어지지 않는 반면 크기가 제한적이라 너무 큰 데이터를 올릴 수 없다는게 단점이다.

힙에는 참조 타입 자료형인 동적 메모리 할당으로 만든 객체 또는 데이터(객체, 배열)가 저장된다. 언제 생기고 언제 없어질지 모르는 데이터를 주로 저장하며, 프로그래머가 직접 관리 또는 자바스크립트 같은 언어는 가비지 컬렉터가 자동으로 관리해준다. 매우 큰 메모리 공간 사용이 가능하며 함수 호출이 끝나도 데이터 유지가 가능하다는 반면 관리가 어렵고 속도가 느리며 메모리 누수, 단편화 문제가 발생할 수 있다.

힙을 사용할 경우 힙에 실제 데이터를 저장하고, 스택에는 그 데이터를 가리키는 주소(포인터, 참조)만 저장한다.

---

### Q. 데이터 타입 primitive(원시)와 reference(참조)의 차이

A. 자바스크립트 데이터 타입에서 원시 타입과 참조 타임은 저장되는 방식, 메모리 구조, 값의 전달 방식이 다르다.

원시 타입은 값 자체가 스택에 저장된다. 문자열은 바뀌지 않고 새로운 문자열이 생성되는 것처럼 한번 생성된 원시 값은 변경이 불가능하다는 불변성을 가지고 있다. 다른 변수에 대입하면 값 자체가 복사된다.

참조 타입은 실제 데이터는 힙에 저장, 변수에는 주소(참조)만 저장된다. 참조 타입인 객체는 값을 자유롭게 변경이 가능하다. 단, 참조 자체를 다른 객체로 바꾸면 새로운 객체를 가리키게 된다. 다른 변수에 대입하면 주소(참조)만 복사되므로 같은 객체를 바라보게 된다.

즉, 원시 타입은 지갑에 돈을 직접 넣고 지갑을 복사하면 돈이 따로따로 생기는 형태라면, 참조 타입은 창고에 물건을 두고, 지갑에는 창고 열쇠만 넣어 열쇠를 복사하면 같은 창고를 공유하는 형태라고 보면 된다.

---

### Q. 가비지 컬렉션이란?

A. 자바스크립트에서의 가바지 컬렉션(GC)는 자바스크립트 엔진이 자동으로 수행하는 메모리 관리 매커니즘이다. 더이상 접근할 수 없는 객체를 GC가 찾아내어 메모리에서 해제한다.

```javascript
let obj = { name: "Jun" };
obj = null; // obj가 참조하던 객체는 이제 접근 불가 -> GC 대상
```

자바스크립트의 핵심 GC 알고리즘은 Mark and Sweep이며 동작원리는 아래와 같다

1. Root 찾기 : 전역 객체(`window`, `globalThis`), 현재 실행 중 함수의 지역변수, 매개변수 콜스택의 참조들을 찾는다.
2. 도달 가능성 검사 : 루트에서 시작해 참조를 따라가며 도달 가능한 객체에 마크한다.
3. Garbage 수거 : 도달 불가능한 객체(참조되지 않는 객체)를 힙 메모리에서 해제한다.

즉, 접근 할 수 있는가가 GC의 기준이지, 변수 값이 null인지 아닌지는 중요하지는 않다.

---

### Q. call by value와 call by reference란?

A. call by value 와 call by reference는 함수 호출 시 인자를 전달하는 방식을 구분하는 개념이다.

call by value(값에 의한 호출)은 인자로 전달될 때 값 자체를 복사해서 함수에 전달하는 방식이다. 함수 안에서 매개변수를 변경해도 원래 변수에는 영향이 없다.

```javascript
function change(x) {
  x = 20;
}

let a = 10;
change(a);
console.log(a); // 10
```

`a`의 값 10이 함수에 복사되어 전달되어 함수 안에서 `x` 값을 바꿔도 원본 `a`는 그대로 유지된다. 즉, 완전 독립적인 값이다.

call by reference(참조에 의한 호출)은 인자로 전달될 때 주소(참조)를 전달하는 방식이다. 함수 안에서 매개변수를 변경하면, 원래 변수도 같이 바뀐다.

```javascript
function change(obj) {
  obj.value = 20;
}

let a = { value: 10 };
change(a);
console.log(a.value); // 20
```

`a`라는 객체가 있는 창고의 열쇠(참조)가 함수에 전달되어 함수 안에서 그 창고 안 물건을 바꾸면 원본도 같이 바뀐다.

자바스크립트는 사실 엄밀히 말하면 모든 인자가 call by value이다. 함수 인자 전달 자체는 항상 call by value이며 무언가가 복사 되어 들어오는 형태다. 원시 값인지 참조 값인지에 따라 동작이 달라지며, 객체도 참조 자체는 값으로 복사된다. 그래서 객체를 함수 안에서 새로운 객체로 재할당하면 원본은 안 바뀐다.

```javascript
function change(obj) {
  obj = { value: 30 };
}

let a = { value: 10 };
change(a);
console.log(a.value); // 10
```

객체인 경우 복사되는 값이 참조값(주소)이기 때문에 함수 안에서 그 참조로 객체 속성을 바꾸면 원본도 바뀌어 보이긴 하나, 객체를 통째로 재할당하면 원본은 안 바뀐다.

`obj.value = 20;` 은 원본 객체의 속성이 바뀌는 것이고, `obj = { value: 30 };` 은 함수 안의 매개변수 참조가 새 객체로 바뀌는 것이므로 원본에 영향이 없다. 자바스크립트는 참조값을 복사한 call by value일 뿐이라고 보면 된다.

그렇다면 자바스크립트에서 call by reference가 존재하지 않는걸까? -> 맞다. 진짜 의미의 call by reference는 존재하지 않는다.

자바스크립트에선 객체의 경우에도 참조값(열쇠)이 복사돼서 전달될 뿐이지, 원본 참조 자체가 함수에 직접 연결되는 건 아니다.

```cpp
void change(int& x) {
  x = 20;
}

int a = 10;
change(a);
cout << a; // 20
```

C++ 예시에서 보면 함수 안에서 매개변수 재할당이 곧 원본에도 반영되는 진짜 call by reference이다.

```javascript
function change(obj) {
  obj = { value: 30 }; // 새로운 객체로 변경
}
let a = { value: 10 };
change(a);
console.log(a.value); // 10 (원본 안 바뀜)
```

만약 자바스크립트가 call bt reference라면 위 결과가 30으로 나와야한다. 하지만 그렇지 않다.

함수 `change` 내에서의 `obj = { value: 30 };`은 힙에 새로운 창고 `{ value: 30 }`가 생성되는 형태가 된다. `obj`라는 변수는 원래 있던 열쇠(참조 값)를 버리고 새 창고의 열쇠로 갈아끼게 된다. 하지만 `a`는 여전히 처음 창고 `{ value: 10 }`의 열쇠를 쥐고 있는 것이다.

자바스크립트가 이렇게 동작하는 이유는 언어 설계 철학과 메모리 모델과 관련이 있다. call by value라는 단일 규칙을 따르게 되면 개발자가 이건 참조, 저건 값으로 가고라는 규칙을 따로 외울 필요 없이 항상 값이 복사된다 라는 규칙만 외우면 된다. 이건 자바스크립트가 쉬운 언어를 목표로 만들어져서 그렇다. 포인터, 레퍼런스 같은 저수준 개념을 숨기고 추상화한 것이다.

객체는 크기가 클 수 있는 이걸 통째로 복사해서 함수에 전달하면 비효율적일수 있다. 그래서 자바스크립트는 객체를 넘길때 참조값만 복사해서 전달하면 메모리, 성능에 이득이 생긴다.

또한, 자바스크립트가 진짜 call by reference였다면 함수 내부에서 재할당 시 원본 변수까지 바뀌어버리면 버그 유발 가능성이 크다고 판단한 이유도 있다.

### Q. 컴파일과 인터프리터란?

A. 컴파일러는 소스 코드를 한번에 읽어서 기계어 또는 중간 코드로 변환하고, 그 결과를 실행 파일이나 목적 코드로 만든다. 그렇기에 프로그램 실행 속도가 빠르며 최적화가 가능하지만 빌드 과정이 필수적이다.

인터프리터는 소스 코드를 한줄씩 읽고 즉시 실행하기 때문에 별도의 실행 파일을 만들지 않는다. 그렇기에 프로그램 실행중 계속 해석하기에 실행 속도가 느리지만, 디버깅이 쉬우며 이식성이 좋다.
