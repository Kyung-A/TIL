# 함수

함수를 정의하는 방법은 3가지이다.

- 함수 선언문 : `function name () { }`
- 함수 표현식 : `const foo = function name() { }`
- Function 생성자 함수

### 1. 함수 선언문과 함수 표현식의 차이점

| 구분                | 함수 선언문                                               | 함수 표현식                                     |
| ------------------- | --------------------------------------------------------- | ----------------------------------------------- |
| 호이스팅            | 함수 전체가 미리 메모리에 등록됨. 선언 이전에도 호출 가능 | 변수만 호이스팅되고 함수 내용은 런타임에 할당됨 |
| 정의 시점           | 코드가 실행되기 전에 미리 정의됨                          | 코드가 실행되는 시점에 정의됨                   |
| 익명 함수 가능 여부 | 항상 이름 필요                                            | 이름 붙일 수도 있고 익명 가능                   |

### 2. 함수 표현식은 언제 사용할까?

함수 표현식은 주로 언제 쓰게 될까?

1. 콜백 함수 : 비동기 처리나 이벤트 처리에서 함수가 다른 함수의 인자로 들어갈때 유용
2. 즉시 실행 함수 : 한번만 실행하고 버릴 함수. 실행 후 바로 가비지 컬렉션 대상
3. 동적 함수 : 함수를 런타임 시점에 조건에 따라 다르게 정의할때
4. 클로저를 만들때
5. 함수를 값처럼 전달할때

React를 사용하면서 주로 함수 선언문 또는 화살표 함수를 사용해왔던 것 같다. 그럼 React에서 함수 선언문과 함수 표현식이 사용될때는 언제일까?

**React에서 함수 선언문이 사용될때**

```javascript
function Header() {
  return <h1>Hello</h1>;
}
```

주로 어떤 UI를 정의할때 사용한다. 이건 컴포넌트가 선언적이라는 React 철학에 따른다. 이렇게 UI 컴포넌트를 함수 선언문으로 작성하면 호이스팅 덕분에 파일 어디서든 사용이 가능하고, 실행중 동적으로 생성할 필요가 거의 없으며, 콜백처럼 즉시 전달할 필요도 없기에 정적인 함수 선언문 형태가 깔끔하다.

**함수 표현식이 사용될때는?**

주로 컴포넌트 내부 로직에서 이벤트 핸들러, 콜랙, 클로저를 사용할때는 함수 표현식이 많이 쓰인다. 어떤 형태로? 우리에게 익숙한 화살표 함수로 쓰이는 것이다.

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return <button onClick={handleClick}>Clicked {count}</button>;
}
```

여기서 `handleClick`은 함수 표현식이다.

그 외에도 React Hook이나 콜백 함수 대부분 함수 표현식 형태로 쓰여진다.

React에서 전통적인 익명 `function` 표현식을 못 봤던 것이지, 실제로는 화살표 함수로 계속 쓰고 있던 것이다.

### 3. 함수 표현식과 화살표 함수의 차이

| 항목                                  | 전통 함수 표현식               | 화살표 함수                           |
| ------------------------------------- | ------------------------------ | ------------------------------------- |
| `this`                                | 호출 방식에 따라 동적으로 결정 | 렉시컬(정의 시점)에 고정. 바뀌지 않음 |
| `call`, `apply`, `bind`로 `this` 변경 | 가능                           | 불가능                                |
| `new` 생성자 호출                     | 가능 (생성자 될 수 있음)       | 불가능                                |
| `prototype`                           | 있음                           | 없음                                  |
| `arguments`                           | 있음                           | 없음. `rest` 파라미터 사용            |
| `super` / `new.target` 바인딩         | 자체 바인딩 가짐               | 없음(밖에서 캡쳐)                     |
| 제너레이터                            | `function\*` 가능              | 불가                                  |

- 객체/클래스 메서드에서 this가 그 객체를 가리켜야함 → `function`
- 콜백/비동기/클로저에서 외부 스코프를 캡쳐하고 싶음 → 화살표
- 생성자/프로토타입 메서드가 필요 → `function`/`class`
- 이벤트 핸들러에서 요소를 this로 쓰고 싶음 → `function`
- 간결한 인라인 콜백(`map`, `filter`, `reduce`, `setTimeout` 등) → 화살표 추천

그래서 **React에서 왜 화살표 함수를 쓰는 경우가 많은가?**를 살펴보면, React는 함수를 중심으로 한 선언적 UI 프레임워크이다. 즉, UI를 클래스나 인스턴스 기반으로 제어하는게 아니라, 입력(`props`, `state`) → 출력(UI)형태의 순수 함수적 구조로 구성된다.

React 16.8 이후로부터 클래스 대신 함수형 컴포넌트, Hooks이 표준이 되면서 인스턴스(`this`)가 아예 존재하지 않고, 상태와 동작을 모두 클로저로 관리한다.

React는 리렌더될 때마다 컴포넌트 함수가 다시 호출된다. 이때 화살표 함수로 정의된 내부 함수들은 그 렌더 시점의 상태를 그대로 기억하는 클로저가 된다. 화살표 함수는 외부 변수를 자연스럽게 캡처(클로저)하고 별도의 `this` 바인딩 없이 안전하게 묶어두는 역할을 해준다.

물론 React는 함수 선언문을 쓰든, 표현식으로 쓰든 동작에 에러는 없다. 그러나 맥락상 React에서는 `this`를 쓸 일이 없으니까, 아예 `this`가 없는 함수를 쓰는게 자연스러워서 선호하는 것 같다.
