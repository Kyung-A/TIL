# 함수

함수를 정의하는 방법은 3가지이다.

- 함수 선언문 : `function name () { }`
- 함수 표현식 : `const foo = function name() { }`
- Function 생성자 함수

### 1. 함수 선언문과 함수 표현식의 차이점

| 구분                | 함수 선언문                                               | 함수 표현식                                     |
| ------------------- | --------------------------------------------------------- | ----------------------------------------------- |
| 호이스팅            | 함수 전체가 미리 메모리에 등록됨. 선언 이전에도 호출 가능 | 변수만 호이스팅되고 함수 내용은 런타임에 할당됨 |
| 정의 시점           | 코드가 실행되기 전에 미리 정의됨                          | 코드가 실행되는 시점에 정의됨                   |
| 익명 함수 가능 여부 | 항상 이름 필요                                            | 이름 붙일 수도 있고 익명 가능                   |

### 2. 함수 표현식은 언제 사용할까?

함수 표현식은 주로 언제 쓰게 될까?

1. 콜백 함수 : 비동기 처리나 이벤트 처리에서 함수가 다른 함수의 인자로 들어갈때 유용
2. 즉시 실행 함수 : 한번만 실행하고 버릴 함수. 실행 후 바로 가비지 컬렉션 대상
3. 동적 함수 : 함수를 런타임 시점에 조건에 따라 다르게 정의할때
4. 클로저를 만들때
5. 함수를 값처럼 전달할때

React를 사용하면서 주로 함수 선언문 또는 화살표 함수를 사용해왔던 것 같다. 그럼 React에서 함수 선언문과 함수 표현식이 사용될때는 언제일까?

**React에서 함수 선언문이 사용될때**

```javascript
function Header() {
  return <h1>Hello</h1>;
}
```

주로 어떤 UI를 정의할때 사용한다. 이건 컴포넌트가 선언적이라는 React 철학에 따른다. 이렇게 UI 컴포넌트를 함수 선언문으로 작성하면 호이스팅 덕분에 파일 어디서든 사용이 가능하고, 실행중 동적으로 생성할 필요가 거의 없으며, 콜백처럼 즉시 전달할 필요도 없기에 정적인 함수 선언문 형태가 깔끔하다.

**함수 표현식이 사용될때는?**

주로 컴포넌트 내부 로직에서 이벤트 핸들러, 콜랙, 클로저를 사용할때는 함수 표현식이 많이 쓰인다. 어떤 형태로? 우리에게 익숙한 화살표 함수로 쓰이는 것이다.

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return <button onClick={handleClick}>Clicked {count}</button>;
}
```

여기서 `handleClick`은 함수 표현식이다.

그 외에도 React Hook이나 콜백 함수 대부분 함수 표현식 형태로 쓰여진다.

React에서 전통적인 익명 `function` 표현식을 못 봤던 것이지, 실제로는 화살표 함수로 계속 쓰고 있던 것이다.

### 3. 함수 표현식과 화살표 함수의 차이

| 항목                                  | 전통 함수 표현식               | 화살표 함수                           |
| ------------------------------------- | ------------------------------ | ------------------------------------- |
| `this`                                | 호출 방식에 따라 동적으로 결정 | 렉시컬(정의 시점)에 고정. 바뀌지 않음 |
| `call`, `apply`, `bind`로 `this` 변경 | 가능                           | 불가능                                |
| `new` 생성자 호출                     | 가능 (생성자 될 수 있음)       | 불가능                                |
| `prototype`                           | 있음                           | 없음                                  |
| `arguments`                           | 있음                           | 없음. `rest` 파라미터 사용            |
| `super` / `new.target` 바인딩         | 자체 바인딩 가짐               | 없음(밖에서 캡쳐)                     |
| 제너레이터                            | `function\*` 가능              | 불가                                  |

- 객체/클래스 메서드에서 this가 그 객체를 가리켜야함 → `function`
- 콜백/비동기/클로저에서 외부 스코프를 캡쳐하고 싶음 → 화살표
- 생성자/프로토타입 메서드가 필요 → `function`/`class`
- 이벤트 핸들러에서 요소를 this로 쓰고 싶음 → `function`
- 간결한 인라인 콜백(`map`, `filter`, `reduce`, `setTimeout` 등) → 화살표 추천

그래서 **React에서 왜 화살표 함수를 쓰는 경우가 많은가?**를 살펴보면, React는 함수를 중심으로 한 선언적 UI 프레임워크이다. 즉, UI를 클래스나 인스턴스 기반으로 제어하는게 아니라, 입력(`props`, `state`) → 출력(UI)형태의 순수 함수적 구조로 구성된다.

React 16.8 이후로부터 클래스 대신 함수형 컴포넌트, Hooks이 표준이 되면서 인스턴스(`this`)가 아예 존재하지 않고, 상태와 동작을 모두 클로저로 관리한다.

React는 리렌더될 때마다 컴포넌트 함수가 다시 호출된다. 이때 화살표 함수로 정의된 내부 함수들은 그 렌더 시점의 상태를 그대로 기억하는 클로저가 된다. 화살표 함수는 외부 변수를 자연스럽게 캡처(클로저)하고 별도의 `this` 바인딩 없이 안전하게 묶어두는 역할을 해준다.

물론 React는 함수 선언문을 쓰든, 표현식으로 쓰든 동작에 에러는 없다. 그러나 맥락상 React에서는 `this`를 쓸 일이 없으니까, 아예 `this`가 없는 함수를 쓰는게 자연스러워서 선호하는 것 같다.

### 4. 함수 선언문/포현식은 결국 Function 생성자 함수의 축약형이다?

piemaweb 웹 사이트의 javascript 12단원을 보면 아래와 같은 문장이 있다.

> 따라서 함수 선언문과 함수 표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function 생성자 함수로 함수를 생성하는 것을 단순화시킨 short-hand(축약법)이다.

이 문장이 진짜 맞는건가? 싶은 의심이 들어서 근거를 더 찾아봤다.

**결론은 함수 선언문과 표현식은 `Function` 생성자 함수의 축약형이 절대! 아니다!**

대체 왜 책에서 이렇게 표현한건지 모르겠다. 맥락상 이해를 위해서인가 싶지만, 오해를 불러일으킬 수 있다고 생각한다. 나같은 경우 위 문장을 읽자마자 든 생각은 '아~ 함수 선언문 또는 표현식으로 작성하면 내부적으로 우리가 마치 `new Function`으로 함수를 생성한것 처럼 동작해서 만들어지나 보다!'라고 이해를 했기 때문이다.

결론은 결국 모든 함수는 `Function` 객체가 되는 것은 맞지만, `new Function`과 같은 동작으로 생성되는게 아니다. [MDN 공식 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions)에서도 함수 선언문, 함수 표현식, `Function` 생성자 함수의 동작 차이를 설명하고 있다.

`ECMAScript` 공식 문서에서도 내부 연산이 다름을 명시하고 있다.

- 함수 선언문/표현식 : 내부 연산자 [OrdinaryFunctionCreate](https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinaryfunctioncreate)를 사용
- `Function` 생성자 함수 : 내부 연산자 [CreateDynamicFunction](https://tc39.es/ecma262/#sec-createdynamicfunction)를 사용

물론 자바스크립트 엔진에 따라 차이는 있을 수도 있다고 한다. 그러나 공식 사양에는 엄연히 동작 방식이 다르다는 것을 설명하고 있다.. 그리고 이 연산자 차이로 인해 가장 두드러지게 나타나는 차이점은 스코프의 범위이다. 함수 선언문/표현식은 렉시컬 스코프를 저장하여 클로저를 가능하게 하는 반면, `Function` 생성자 함수는 문자열로 함수를 만들고 전역 환경에서 실행된다는 것이다.

이 외에도 파싱 시점도 다르며, 절대로 추가 설명 없이 단순 축약형이다 라고만 설명하면 오해가 생길 수 밖에 없다.

> 14단원에서도 '객체 리터럴 방식으로 생성된 객체는 결국 내장 함수(Built-in)인 `Object()` 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 `Object()` 생성자 함수를 사용하여 객체를 생성한다.' 라는 문장이 있는데 이 또한 오해가 발생할 수 있는 문장이다. 자바스크립트 엔진은 객체 리터럴 `{}`를 만났을때 내부적으로 `Object()` 생성자 함수를 호출하지 않는다.
