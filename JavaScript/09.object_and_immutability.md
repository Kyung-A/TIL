# 객체와 변경불가성

### 1. 객체(Object)란?

자바스크립트는 객체 기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 모든 것들이 객체로 되어있다. 원시 타입을 제외한 나머지 값들(함수, 배열, 정규표현식 등) 모두 객체이다.

자바스크립트의 객체는 key와 value로 구성된 프로퍼티들의 집합이다. 데이터를 의미하는(키의 값) 프로퍼티와 데이터를 참조하고 조작할 수 있는 동작을 의미하는 메소드로 구성되어있다.

자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 프로토타입이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다.

또한, 배열과 달리 객체는 프로퍼티를 열거할 때 순서를 보장하지 않는다.

### 2. 객체 생성 방법

1. `class` 키워드
2. 객체 리터럴 `{}`
3. Object 생성자 함수
4. 생성자 함수

4번 생성자 함수같은 경우 객체를 생성하기 위한 템플릿처럼 사용하여 프로퍼티가 동일한 객체 여러개를 간편하게 생성할 수 있다.

```javascript
function Person(name, gender) {
  this.name = name;
  this.gender = gender;
  this.sayHello = function () {
    console.log("Hi! My name is " + this.name);
  };
}

// 인스턴스 생성
let person1 = new Person("Lee", "male");
let person2 = new Person("Kim", "female");
```

생성자 함수 이름은 일반적으로 대문자로 시작한다. 이유는 일반 함수와 구별하기 위해서이다.

`this`는 생성자 함수가 생성할 인스턴스를 가리킨다. `this`에 연결(바인딩)되어 있는 프로퍼티와 메소드는 외부에서 참조가 가능하지만, 생성자 함수 내에서 선언된 일반 변수는 외부에서 참조 불가능하다.

ES6 이전에는 생성자 함수를 사용했으나 ES6부터 도입된 `class`를 사용하는게 더 깔끔하고 권장되는 방식이다.

### 3. 객체 프로퍼티 접근

1. 프로퍼티 값 읽기: 마침표, 대괄호 사용 `person['name']`, `person.name`
2. 프로퍼티 값 갱신: 새로운 값을 할당 `person[name] = 'Kim'`
3. 프로퍼티 동적 생성: 객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당 `person.age = 20`
4. 프로퍼티 삭제: `delete` 연산자 사용
5. 객체 프로퍼티 순회: `for-in`문

### 4. pass-by-reference와 pass-by-value

[해당 문서 참고](https://github.com/Kyung-A/TIL/blob/main/JavaScript/05.interim%20check.md#q-call-by-value%EC%99%80-call-by-reference%EB%9E%80)

### 5. 불변 데이터 패턴

객체는 변경이 가능한 값(mutable value)이다. 즉, 객체는 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다. 그래서 의도치 않은 객체의 변경이 발생할 수 있다.

객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사를 통해 새로운 객체를 생성한 후 변경하는 것이 좋다.

#### 5-1. Object.assign

`Object.assign`은 타겟 객체로 소스 객체의 프로퍼티를 복사한다.

```javascript
// 문법
Object.assign(target, ...sources);

const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
console.log(obj == copy); // false
```

하지만 `Object.assign`은 완전한 deep copy를 지원하지 않는다. 객체 내부의 객체는 shallow copy가 되며, 원본 객체의 내부 객체를 수정하면 복사한 객체의 내부 객체 값도 같이 수정된다.

```javascript
const user1 = {
  name: "Lee",
  address: {
    city: "Seoul",
  },
};

const user2 = Object.assign({}, user1);

user1.address.city = "Busan";
console.log(user1.address.city); // Busan
console.log(user2.address.city); // Busan
```

`user1` 객체는 힙에 생성되고, `user1.address`는 별도의 객체로 힙에 생성된다. `user1`은 그 주소(참조값)를 갖고 있다.

`Object.assign`은 얕은 복사(Shallow copy)를 하기 때문에 중첩 객체는 복사되지 않고 참조만 복사된다. `user1.address`와 `user2.address`는 서로 다른 변수가 같은 객체(참조값. 주소)를 가리키게 된다.

#### 5-2. Object.freeze

`Object.freeze`를 사용하여 불변 객체로 만들 수 있다.

```javascript
const user1 = {
  name: "Lee",
  address: {
    city: "Seoul",
  },
};

Object.freeze(user1);
user1.name = "Jun"; // 무시됨
```

하지만 여전히 객체 내부의 객체는 변경이 가능하다.

내부 객체까지 변경 불가능하게 만들려면 Deep freeze를 하는 별도의 로직을 작성해줘야 한다.
