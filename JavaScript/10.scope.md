# 스코프

### 1. 렉시컬 스코프

스코프 종류에는 전역 스코프, 지역 스코프가 있다. 그리고 또 나오는게 렉시컬 스코프인데 앞서 말한 두종류의 스코프처럼 렉시컬에도 스코프란 단어가 붙어있으니 마치 전역, 지역처럼 렉시컬은 어디까지 영역을 끼치는거지?란 생각이 들게된다.

신입때 분명 이와 같은 생각이 떠올라서 정리했던 것 같은데, 똑같은 생각을 또 하고 있다. 그래서 다시 정리해본다.

렉시컬 스코프는 전역, 지역 스코프와 같은 종류중 하나가 아니라, 그 두 스코프를 포함하는 **스코프의 결정 방식**을 의미한다.

렉시컬 스코프는 함수를 어디서 선언하였는지에 따라 스코프가 결정된다. 실행할때(런타임) 시점이 아닌, 작성할때(정의 시점) 이미 스코프가 정해지는 것이다. 자바스크립트는 렉시컬 스코프의 방식을 따른다.

### 2. 암묵적 전역이 발생하는 이유

```javascript
function foo() {
  x = 10;
}

foo();

console.log(x); // 10
```

자바스크립트는 위처럼 변수 선언을 하지 않았음에도 자동으로 전역 변수를 선언한 것 처럼 동작한다.

자바스크립트 엔진은 `x`를 찾기위해 아래와 같이 탐색한다.

1. 현재 스코프의 변수 환경에서 `x`를 찾음
2. 없다면 상위 렉시컬 스코프로 올라가며 계속 탐색
3. 전역 스코프까지 가도 없다면? -> 전역 객체(window/globalThis)에 새 프로퍼티로 추가해버림

이와 같이 전역 변수가 생성된 것이 아닌 단지 전역 객체의 프로퍼티로 추가되었을 뿐이다. 그래서 `x`는 `delete` 연산자로 삭제할 수 있다.

왜 이런 설계를 했을까?

GPT의 답변으로는 초기 자바스크립트의 탄생과 관련이 있다고 설명한다.

1. 오류가 있어도 페이지가 돌아갈 수 있도록 유연성, 관용성을 중요시 했기 때문
2. 초창기엔 모듈/패키징이 없었기에 `<script>`태그끼리 변수를 쉽게 공유할 수 있어야 했음
3. 전역 스코프와 전역 객체가 밀접하게 연결되어 있어서 전역 스코프의 바인딩을 전역 객체의 프로퍼티로 처리하는 모델이 기본 구조로 자리 잡았음 -> ES6 이후에는 `var`와 함수 선언문만 해당
4. 호환성 유지를 위해 지금까지도 이 동작을 허용
