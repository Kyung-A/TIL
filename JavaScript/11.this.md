# this

`this`를 공부하는 중 아래 예제에서 왜 setTimeout의 콜백 함수 내부의 this가 window인지 궁금해졌다.

```javascript
var value = 1;

var obj = {
  value: 100,
  foo: function () {
    setTimeout(function () {
      console.log("callback's this: ", this); // window
      console.log("callback's this.value: ", this.value); // 1
    }, 100);
  },
};

obj.foo();
```

일단 설계적 결함으로 `this`는 내부 함수일 경우 `window`를 향한다는건 이해했다. (중첩된 함수에서 내부 함수)

처음에는 단순하게 콜백 함수가 특정 동작이 진행 된 후에 실행되는 함수다보니 이럴땐 전역 스코프를 가지게 되는거라서 그런가? 라고 생각했지만, 생각해보면 자바스크립트는 함수를 선언한 시정메 스코프가 결정되는건데, 그럼 `setTimeout` 함수의 스코프를 가지게 되는거 아닌가? 그러면 `setTimeout` 함수는 `foo`라는 이름을 가지는 함수 메서드 안에 선언된건데, 그러면 결국 내부 스코프로 `this`가 obj를 향해야 하는거 아닌가? 이러면서 대충 렉시컬 스코프와 헷갈리기 시작했다.

그래서 GPT한테 물어본 결과, 스코프의 개념은 잘 이해했지만 `this`는 스코프와 아무 상관이 없는 값이라고 한다. 책에서도 `this` 바인딩이랑 렉시컬 스코프를 혼동하지 말라고는 했지만 진짜 혼동될 수 밖에 없는 것 같다.

`this`는 함수를 호출할때 함수가 어떻게 호출 되었는지에 따라 달라진다. 즉, 누가 이 함수를 호출 했는지이다.

```javascript
function show() {
  console.log(this.value);
}

const obj = {
  value: 1000,
  show,
};

obj.show(); // 100;
show(); // undefined
```

이렇게 this 누가 이 함수를 호출 했는지에 따라 달라진다.

그리고 내가 아마 다른 예제는 이해해놓고 `setTimeout` 예제에서만 혼동된건 아마도 `setTimeout`의 내부 동작을 이해하지 못해서인 것 같다.

`setTimeout`은 전역 함수다. 브라우저 환경에서 전역 객체 window의 메서드로 정의되어있다. 그래서 특정 객체의 메서드로 정의해도 해당 객체의 메서드로 호출되는게 아니라 전역 함수로 등록되어 실행되기 때문에 콜백 함수도 전역 컨텍스트에서 호출된다.

`obj.setTimeout()`이런식으로 호출했다고 하더라도, 자바스크립트 엔진은 `window.setTimeout`으로 호출하게 된다. 콜백 함수도 그렇다. 개념적으로 설명하자면 아래 코드와 같은 느낌인거다.

```javascript
function setTimeout(callback, delay) {
  // ...
  callback();
}
```

그리고 위와 비슷한 예제로 또 헷갈리게 하는 예제가 있다

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.doSomething = function (callback) {
  if (typeof callback == "function") {
    callback();
  }
};

function foo() {
  console.log(this.name);
}

var p = new Person("Lee");
p.doSomething(foo); // undefined
```

위 예제도 마치 `foo` 함수의 `this`가 `Person`을 가리킬 것 같은데 전혀 아니다. 이유는 똑같이 `callback` 함수의 호출 시점이다. 이 또한 단독으로 함수를 호출한 것과 같은 원리가 된다.

나는 변수 `p`의 프로토타입이 `Person`이니까 호출 주체가 있는거 아니야? 라고 생각했는데 **`this`의 바인딩은 프로토타입 체인과 무관**하다고 한다. 즉, 호출 주체는 변수 `p`인거지 `Person`으로 대체되는 것이 아니다. 변수 `p`에 없는 것을 `Person`에서 끌어다가 `this` 바인딩을 또 동적으로 바꾸는 것은 아니라는 것. 프로토타입 체인은 단지 변수 `p`에 해당하는 프로퍼티(`doSomething`)가 없을때 그걸 찾아주는 경로일 뿐이다.
