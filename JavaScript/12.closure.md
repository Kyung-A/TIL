# 클로저

클로저는 함수와 그 함수가 선언됐을때의 렉시컬 환경과의 조합이다. 클로저는 자바스크립트에서만 쓰이는 개념은 아니며 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.

```javascript
function outerFunc() {
  var x = 10;
  var innerFunc = function () {
    console.log(x);
  };
  return innerFunc;
}

var inner = outerFunc();
inner();
```

```javascript
function outerFunc() {
  var x = 10;
  var innerFunc = function () {
    console.log(x);
  };
  return innerFunc;
}

outerFunc();
```

나는 위 두 예제를 통해 똑같이 클로저가 발생하는 경우가 아닌가? 라고 생각했다. 클로저는 반환된 내부 함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여 자신이 선언됐을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수라고 했으니 두 예제 모두 포함되는 설명이라고 생각했다.

하지만, 클로저의 핵심 포인트중 하나인 이처럼 클로저가 된 함수의 내부 변수(자유 변수)는 최신 상태로 업데이트, 유지가 가능하다인데 2번째 예제 같은 경우에는 자유 변수를 업데이트 할 방법이 없는 코드이다.

그래서 드는 생각이 그럼 2번째 예제는 클로저가 아닌건가? 라고 생각했는데, 클로저가 적용된건 맞다. 다만 차이점이 있다.

1번째 예제 같은 경우 `var inner = outerFunc()` 코드를 보면 `inner` 변수에 `outerFunc()` 리턴값인 `innerFunc` 함수를 게속해서 참조 유지를 하고 있기 때문에 클로저가 생성되고 **유지**가 되는 상태이다.

반면, 2번째 예제는 실행중에는 `innerFunc` 가 자유변수 `x`에 접근하므로 클로저 상태가 되지만, `outerFunc`의 리턴값을 어디에도 저장하지 않기 때문에, `outerFunc`가 끝나는 순간 `innerFunc`에 대한 참조도 사라지기에 가비지 컬렉터에의해 정리가 되어비린다. 즉, 클로저가 일시적으로 유지되었다가 소멸되는 것이다.

두 예제 모두 클로저에 해당은 하지만, 유지가 되었냐 안되었냐의 큰 차이를 두고 있다.

> 참고: 예제에서 사용된 자유 변수 x는 캡슐화와 유사하다. 다만 this로 선언하게 되면, public이 되니 유의해야한다. 참고로 반환값을 모듈 패턴으로 반환할 경우 (메소드를 객체 형태로 만들어서 반환) 얕은 복사로 반환되는 것이니, 반드시 새로운 객체에 담아서 반환하든 깊은 복사로 복사본을 만들어서 반환해준다.
